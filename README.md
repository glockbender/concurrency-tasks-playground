# concurrency-tasks-playground

Тестовый прототип распределенной системы.

Система обрабатывает приходящие данные продолжительное время (Длительные запросы в БД, которые необходимо минимизировать). 
Во время обработки данных или ожидания соотв. таски в очереди на выполнение другие потребители могут запросить обработку тех же самых данных, 
следовательно необходимо отслеживать состояние обрабатываемых на текущий момент данных, 
чтобы новые потребители могли подписаться на обработку, которая уже находится в очереди.
Также некоторые данные необходимо обработать с высоким приоритетом, 
в т.ч. если задача уже находится в очереди на обработку, ее приоритет необходимо повысить.
Также важным условием является необходимость синхронизации с потоком-потребителем, 
т.к. если запрос идет из вэб-фронта - требуется ответ в тот же поток, откуда поступал запрос 
(иначе придется использовать альтернативу в виде WebSocket, RPC, server sent events)

В основе реализации лежит ThreadPoolExecutor, основанный на очереди типа PrioityBlockedQueue. 
В данный executor отправляются Runnable таски с типом, реализующим Comparable. Это позволяет работать с приоритетом выполнения. 
Также в переопределенные методы beforeExecute и afterExecute передаются коллбэки из внешнего сервиса для возможности управления состоянием, 
отслеживающим список тасок "в ожидании"/"выполняющихся в текущий момент". Для этого во внешнем сервисе используются мапы, 
где ключ - данные, значение - таска, отправленная в executor. Для синхронизации потоков-потребителей, 
т.е. чтобы они могли ожидать выполнения обработки своих данных и получить результат сразу по факту завершения обработки, используется CountDownLatch с одним тиком. 
На каждую таску вешается соответствующий latch и по окончанию обработки в executor'e данные передаются в сервис и там хранятся в мапе. 
Далее выполняется тик latch'a, и все ожидающие потоки (т.е. во всех потоках-потребителях вызывается latch.await()) лезут в мапу за готовыми данными. 
